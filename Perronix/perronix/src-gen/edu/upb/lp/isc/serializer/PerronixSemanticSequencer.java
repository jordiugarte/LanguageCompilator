/*
 * generated by Xtext 2.21.0
 */
package edu.upb.lp.isc.serializer;

import com.google.inject.Inject;
import edu.upb.lp.isc.perronix.ArithExpression;
import edu.upb.lp.isc.perronix.Define;
import edu.upb.lp.isc.perronix.DoubleExpression;
import edu.upb.lp.isc.perronix.FunctionCallExpression;
import edu.upb.lp.isc.perronix.IfExpression;
import edu.upb.lp.isc.perronix.IntExpression;
import edu.upb.lp.isc.perronix.ListDouble;
import edu.upb.lp.isc.perronix.ListInt;
import edu.upb.lp.isc.perronix.ListString;
import edu.upb.lp.isc.perronix.MyRacketProgram;
import edu.upb.lp.isc.perronix.PerronixPackage;
import edu.upb.lp.isc.perronix.PrintExpression;
import edu.upb.lp.isc.perronix.StringExpression;
import edu.upb.lp.isc.services.PerronixGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PerronixSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PerronixGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PerronixPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PerronixPackage.ARITH_EXPRESSION:
				sequence_ArithExpression(context, (ArithExpression) semanticObject); 
				return; 
			case PerronixPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case PerronixPackage.DOUBLE_EXPRESSION:
				sequence_DoubleExpression(context, (DoubleExpression) semanticObject); 
				return; 
			case PerronixPackage.FUNCTION_CALL_EXPRESSION:
				sequence_FunctionCallExpression(context, (FunctionCallExpression) semanticObject); 
				return; 
			case PerronixPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case PerronixPackage.INT_EXPRESSION:
				sequence_IntExpression(context, (IntExpression) semanticObject); 
				return; 
			case PerronixPackage.LIST_DOUBLE:
				sequence_ListDouble(context, (ListDouble) semanticObject); 
				return; 
			case PerronixPackage.LIST_INT:
				sequence_ListInt(context, (ListInt) semanticObject); 
				return; 
			case PerronixPackage.LIST_STRING:
				sequence_ListString(context, (ListString) semanticObject); 
				return; 
			case PerronixPackage.MY_RACKET_PROGRAM:
				sequence_MyRacketProgram(context, (MyRacketProgram) semanticObject); 
				return; 
			case PerronixPackage.PRINT_EXPRESSION:
				sequence_PrintExpression(context, (PrintExpression) semanticObject); 
				return; 
			case PerronixPackage.STRING_EXPRESSION:
				sequence_StringExpression(context, (StringExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns ArithExpression
	 *     ArithExpression returns ArithExpression
	 *
	 * Constraint:
	 *     ((op='+' | op='-' | op='*' | op='/') args+=Expression args+=Expression+)
	 */
	protected void sequence_ArithExpression(ISerializationContext context, ArithExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Define returns Define
	 *
	 * Constraint:
	 *     (name=ID params+=ID* body=Expression)
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DoubleExpression
	 *     PrintExpression returns DoubleExpression
	 *     DoubleExpression returns DoubleExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_DoubleExpression(ISerializationContext context, DoubleExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.PRINT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.PRINT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoubleExpressionAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCallExpression
	 *     FunctionCallExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=[Define|ID] args=Expression*)
	 */
	protected void sequence_FunctionCallExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfExpression
	 *     IfExpression returns IfExpression
	 *
	 * Constraint:
	 *     (cond=Expression then=Expression else=Expression)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.IF_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.IF_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.IF_EXPRESSION__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.IF_EXPRESSION__THEN));
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.IF_EXPRESSION__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.IF_EXPRESSION__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpressionAccess().getCondExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getIfExpressionAccess().getThenExpressionParserRuleCall_5_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getIfExpressionAccess().getElseExpressionParserRuleCall_6_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntExpression
	 *     SimpleExpression returns IntExpression
	 *     IntExpression returns IntExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntExpression(ISerializationContext context, IntExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.INT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.INT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListDouble
	 *     ListDouble returns ListDouble
	 *
	 * Constraint:
	 *     t+=DoubleExpression+
	 */
	protected void sequence_ListDouble(ISerializationContext context, ListDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListInt
	 *     ListInt returns ListInt
	 *     LengthList returns ListInt
	 *     ListTail returns ListInt
	 *
	 * Constraint:
	 *     s+=IntExpression+
	 */
	protected void sequence_ListInt(ISerializationContext context, ListInt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListString
	 *     ListString returns ListString
	 *
	 * Constraint:
	 *     t+=StringExpression
	 */
	protected void sequence_ListString(ISerializationContext context, ListString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MyRacketProgram returns MyRacketProgram
	 *
	 * Constraint:
	 *     (defines+=Define* executions+=Expression+)
	 */
	protected void sequence_MyRacketProgram(ISerializationContext context, MyRacketProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrintExpression
	 *     PrintExpression returns PrintExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_PrintExpression(ISerializationContext context, PrintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.PRINT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.PRINT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintExpressionAccess().getValueINTTerminalRuleCall_0_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringExpression returns StringExpression
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringExpression(ISerializationContext context, StringExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerronixPackage.Literals.STRING_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerronixPackage.Literals.STRING_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringExpressionAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
